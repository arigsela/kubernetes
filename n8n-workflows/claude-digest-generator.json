{
  "name": "Claude Digest Generator",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Daily 8 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 304]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n    url, title, content_snippet, source_name, category, pub_date,\n    metadata->>'author' as author,\n    metadata->>'comments_count' as engagement\nFROM feed_articles\nWHERE 'claude' = ANY(topic)\n  AND pub_date >= NOW() - INTERVAL '24 hours'\n  AND (last_digest_date IS NULL OR last_digest_date < CURRENT_DATE)\nORDER BY pub_date DESC\nLIMIT 30;",
        "options": {}
      },
      "id": "query-articles",
      "name": "Query Claude Articles",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [240, 304],
      "credentials": {
        "postgres": {
          "id": "GCohHH3qGUDCi7xo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-results",
              "leftValue": "={{ $json.url }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-has-articles",
      "name": "Has Articles?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [448, 304]
    },
    {
      "parameters": {
        "jsCode": "// Combine all items into a single text for the LLM\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  return [{\n    json: {\n      posts: 'No new articles found for today.',\n      date: new Date().toISOString().split('T')[0],\n      itemCount: 0,\n      urls: []\n    }\n  }];\n}\n\nconst postsText = items.map((item, index) => {\n  const json = item.json;\n  return `### Post ${index + 1}\n**Title:** ${json.title}\n**Source:** ${json.source_name} (${json.category})\n**Date:** ${json.pub_date}\n**Link:** ${json.url}\n**Content Preview:** ${json.content_snippet || 'No content'}\n`;\n}).join('\\n---\\n');\n\n// Collect URLs for marking as processed later\nconst urls = items.map(item => item.json.url);\n\nreturn [{\n  json: {\n    posts: postsText,\n    date: new Date().toISOString().split('T')[0],\n    itemCount: items.length,\n    urls: urls\n  }\n}];"
      },
      "id": "prepare-for-llm",
      "name": "Prepare for LLM",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [656, 224]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-haiku-4-5-20251001",
          "mode": "list",
          "cachedResultName": "Claude Haiku 4.5"
        },
        "options": {
          "maxTokensToSample": 4096
        }
      },
      "id": "anthropic-model",
      "name": "Claude Haiku",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [864, 400]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a helpful assistant that creates daily news digests about Claude AI and Anthropic.\n\nYou have memory of your previous daily digest summaries. Use this memory to:\n- Focus on NEW content not covered in previous summaries\n- Avoid repeating information from previous digests\n- Reference trends or ongoing discussions if relevant\n\n## Today's Posts ({{ $json.itemCount }} articles from database):\n{{ $json.posts }}\n\n## Instructions:\nCreate a markdown-formatted daily digest with these sections:\n\n1. **Key Updates** - Major announcements, new features, or important news\n2. **Hot Discussions** - Interesting community discussions or debates\n3. **Tips & Tricks** - Useful tips shared by the community\n4. **Issues & Bugs** - Notable problems or bugs reported\n\nFor each item, include the source name in parentheses.\nKeep summaries concise but informative.\nIf a section has no relevant NEW content, write \"No notable items today.\"\n\nFormat the output as clean markdown suitable for Notion.",
        "options": {}
      },
      "id": "ai-agent",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [864, 224]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "claude-daily-digest",
        "contextWindowLength": 10
      },
      "id": "simple-memory",
      "name": "Simple Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [864, 480]
    },
    {
      "parameters": {
        "language": "javaScript",
        "mode": "runOnceForAllItems",
        "jsCode": "const item = $input.first();\n// AI Agent outputs to 'output' field, chainLlm outputs to 'text'\nconst text = item.json.output || item.json.text || '';\nconst urls = $('Prepare for LLM').first().json.urls || [];\nconst maxLength = 1900;\nconst maxBlocks = 98;\n\nfunction parseRichText(text) {\n  const segments = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    const boldMatch = remaining.match(/^\\*\\*(.+?)\\*\\*/);\n    const italicMatch = remaining.match(/^\\*(.+?)\\*/);\n    const codeMatch = remaining.match(/^`(.+?)`/);\n    const linkMatch = remaining.match(/^\\[(.+?)\\]\\((.+?)\\)/);\n    \n    if (boldMatch) {\n      segments.push({ type: 'text', text: { content: boldMatch[1] }, annotations: { bold: true } });\n      remaining = remaining.substring(boldMatch[0].length);\n    } else if (codeMatch) {\n      segments.push({ type: 'text', text: { content: codeMatch[1] }, annotations: { code: true } });\n      remaining = remaining.substring(codeMatch[0].length);\n    } else if (linkMatch) {\n      segments.push({ type: 'text', text: { content: linkMatch[1], link: { url: linkMatch[2] } } });\n      remaining = remaining.substring(linkMatch[0].length);\n    } else if (italicMatch && !remaining.startsWith('**')) {\n      segments.push({ type: 'text', text: { content: italicMatch[1] }, annotations: { italic: true } });\n      remaining = remaining.substring(italicMatch[0].length);\n    } else {\n      const nextSpecial = remaining.search(/\\*|`|\\[/);\n      const plainEnd = nextSpecial === -1 ? remaining.length : nextSpecial;\n      if (plainEnd > 0) {\n        segments.push({ type: 'text', text: { content: remaining.substring(0, plainEnd) } });\n        remaining = remaining.substring(plainEnd);\n      } else {\n        segments.push({ type: 'text', text: { content: remaining[0] } });\n        remaining = remaining.substring(1);\n      }\n    }\n  }\n  \n  return segments.length > 0 ? segments : [{ type: 'text', text: { content: text } }];\n}\n\nfunction splitRichText(segments) {\n  const result = [];\n  let current = [];\n  let currentLen = 0;\n  \n  for (const seg of segments) {\n    const content = seg.text.content;\n    if (currentLen + content.length <= maxLength) {\n      current.push(seg);\n      currentLen += content.length;\n    } else {\n      if (current.length > 0) result.push(current);\n      current = [seg];\n      currentLen = content.length;\n    }\n  }\n  if (current.length > 0) result.push(current);\n  return result;\n}\n\nconst lines = text.split('\\n');\nconst children = [];\n\nfor (const line of lines) {\n  if (children.length >= maxBlocks) break;\n  \n  const trimmed = line.trim();\n  if (!trimmed) continue;\n  \n  if (trimmed.startsWith('# ')) {\n    children.push({ object: 'block', type: 'heading_1', heading_1: { rich_text: parseRichText(trimmed.substring(2)) } });\n  } else if (trimmed.startsWith('## ')) {\n    children.push({ object: 'block', type: 'heading_2', heading_2: { rich_text: parseRichText(trimmed.substring(3)) } });\n  } else if (trimmed.startsWith('### ')) {\n    children.push({ object: 'block', type: 'heading_3', heading_3: { rich_text: parseRichText(trimmed.substring(4)) } });\n  } else if (trimmed === '---' || trimmed === '***' || trimmed === '___') {\n    children.push({ object: 'block', type: 'divider', divider: {} });\n  } else if (trimmed.startsWith('- ')) {\n    const richText = parseRichText(trimmed.substring(2));\n    const chunks = splitRichText(richText);\n    for (const chunk of chunks) {\n      if (children.length >= maxBlocks) break;\n      children.push({ object: 'block', type: 'bulleted_list_item', bulleted_list_item: { rich_text: chunk } });\n    }\n  } else if (/^\\d+\\.\\s/.test(trimmed)) {\n    const content = trimmed.replace(/^\\d+\\.\\s/, '');\n    children.push({ object: 'block', type: 'numbered_list_item', numbered_list_item: { rich_text: parseRichText(content) } });\n  } else {\n    const richText = parseRichText(trimmed);\n    const chunks = splitRichText(richText);\n    for (const chunk of chunks) {\n      if (children.length >= maxBlocks) break;\n      children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: chunk } });\n    }\n  }\n}\n\nreturn [{ json: { notionChildren: children, date: new Date().toISOString().split('T')[0], urls: urls } }];"
      },
      "id": "format-for-notion",
      "name": "Format for Notion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1072, 224]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/pages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Notion-Version", "value": "2022-06-28" },
            { "name": "Content-Type", "value": "application/json" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ parent: { page_id: '2d38e013c07f80c59d93c9aeb9e271b7' }, properties: { title: [{ text: { content: 'Claude - ' + $json.date } }] }, children: $json.notionChildren }) }}",
        "options": {}
      },
      "id": "create-child-page",
      "name": "Create Notion Child Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1280, 224],
      "notesInFlow": true,
      "notes": "Requires 'Header Auth' credential with: Name=Authorization, Value=Bearer YOUR_NOTION_TOKEN"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ 'UPDATE feed_articles SET last_digest_date = CURRENT_DATE, is_processed = true WHERE url = ANY(ARRAY[' + $('Prepare for LLM').first().json.urls.map(u => \"'\" + u.replace(/'/g, \"''\") + \"'\").join(',') + ']);' }}",
        "options": {}
      },
      "id": "mark-processed",
      "name": "Mark as Processed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1488, 224],
      "credentials": {
        "postgres": {
          "id": "GCohHH3qGUDCi7xo",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {},
      "id": "no-articles",
      "name": "No New Articles",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [656, 384]
    }
  ],
  "connections": {
    "Daily 8 AM": {
      "main": [[{ "node": "Query Claude Articles", "type": "main", "index": 0 }]]
    },
    "Query Claude Articles": {
      "main": [[{ "node": "Has Articles?", "type": "main", "index": 0 }]]
    },
    "Has Articles?": {
      "main": [
        [{ "node": "Prepare for LLM", "type": "main", "index": 0 }],
        [{ "node": "No New Articles", "type": "main", "index": 0 }]
      ]
    },
    "Prepare for LLM": {
      "main": [[{ "node": "AI Agent", "type": "main", "index": 0 }]]
    },
    "Claude Haiku": {
      "ai_languageModel": [[{ "node": "AI Agent", "type": "ai_languageModel", "index": 0 }]]
    },
    "Simple Memory": {
      "ai_memory": [[{ "node": "AI Agent", "type": "ai_memory", "index": 0 }]]
    },
    "AI Agent": {
      "main": [[{ "node": "Format for Notion", "type": "main", "index": 0 }]]
    },
    "Format for Notion": {
      "main": [[{ "node": "Create Notion Child Page", "type": "main", "index": 0 }]]
    },
    "Create Notion Child Page": {
      "main": [[{ "node": "Mark as Processed", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/New_York",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "meta": {
    "notes": "Claude AI digest generator. Queries PostgreSQL for claude-tagged articles from the last 24 hours, generates a digest using AI Agent with memory, creates a Notion page, and marks articles as processed."
  }
}
