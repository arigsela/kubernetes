{
  "name": "DevOps Feed Aggregator",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Daily Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 464]
    },
    {
      "parameters": {
        "url": "https://devops.com/feed/",
        "options": {}
      },
      "id": "rss-devops-com",
      "name": "RSS DevOps.com",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 80]
    },
    {
      "parameters": {
        "url": "https://theagileadmin.com/feed/",
        "options": {}
      },
      "id": "rss-agile-admin",
      "name": "RSS Agile Admin",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 192]
    },
    {
      "parameters": {
        "url": "https://feed.infoq.com/Devops/articles/",
        "options": {}
      },
      "id": "rss-infoq",
      "name": "RSS InfoQ DevOps",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 288]
    },
    {
      "parameters": {
        "url": "https://devops-daily.com/feed.xml",
        "options": {}
      },
      "id": "rss-devops-daily",
      "name": "RSS DevOps Daily",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 384]
    },
    {
      "parameters": {
        "url": "https://www.hashicorp.com/blog/feed.xml",
        "options": {}
      },
      "id": "rss-hashicorp",
      "name": "RSS HashiCorp",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 480]
    },
    {
      "parameters": {
        "url": "https://www.cncf.io/blog/feed/",
        "options": {}
      },
      "id": "rss-cncf",
      "name": "RSS CNCF",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 592]
    },
    {
      "parameters": {
        "url": "https://kubernetes.io/feed.xml",
        "options": {}
      },
      "id": "rss-kubernetes",
      "name": "RSS Kubernetes",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 688]
    },
    {
      "parameters": {
        "url": "https://hnrss.org/newest?q=kubernetes+OR+devops+OR+terraform",
        "options": {}
      },
      "id": "rss-hn-devops",
      "name": "RSS HN DevOps",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 784]
    },
    {
      "parameters": {
        "url": "https://www.reddit.com/r/devops/.rss",
        "options": {}
      },
      "id": "rss-reddit-devops",
      "name": "RSS r/devops",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 880]
    },
    {
      "parameters": {
        "url": "https://www.reddit.com/r/kubernetes/.rss",
        "options": {}
      },
      "id": "rss-reddit-k8s",
      "name": "RSS r/kubernetes",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [288, 992]
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "id": "merge-feeds",
      "name": "Merge All Feeds",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [560, 464]
    },
    {
      "parameters": {
        "jsCode": "// Filter posts from last 7 days and sort by date\nconst now = new Date();\nconst sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\nconst items = $input.all();\nconst seen = new Set();\n\nif (!items || items.length === 0) {\n  return [{\n    json: {\n      title: 'No posts found',\n      link: '',\n      pubDate: now.toISOString(),\n      source: 'System',\n      category: 'System',\n      content: 'No RSS feed data was retrieved. Check feed URLs.'\n    }\n  }];\n}\n\nconst filtered = items\n  .map(item => {\n    const json = item.json;\n    const pubDate = new Date(json.pubDate || json.isoDate || json.date || json.updated || now);\n    \n    let source = 'Unknown';\n    let category = 'Blog';\n    \n    if (json.link?.includes('devops.com')) { source = 'DevOps.com'; category = 'Blog'; }\n    else if (json.link?.includes('theagileadmin.com')) { source = 'Agile Admin'; category = 'Blog'; }\n    else if (json.link?.includes('infoq.com')) { source = 'InfoQ'; category = 'Blog'; }\n    else if (json.link?.includes('devops-daily.com')) { source = 'DevOps Daily'; category = 'Blog'; }\n    else if (json.link?.includes('hashicorp.com')) { source = 'HashiCorp'; category = 'Infrastructure'; }\n    else if (json.link?.includes('cncf.io')) { source = 'CNCF'; category = 'Infrastructure'; }\n    else if (json.link?.includes('kubernetes.io')) { source = 'Kubernetes'; category = 'Infrastructure'; }\n    else if (json.link?.includes('news.ycombinator.com')) { source = 'Hacker News'; category = 'Community'; }\n    else if (json.link?.includes('reddit.com/r/devops')) { source = 'r/devops'; category = 'Community'; }\n    else if (json.link?.includes('reddit.com/r/kubernetes')) { source = 'r/kubernetes'; category = 'Community'; }\n    else if (json.creator) source = json.creator;\n    \n    return {\n      title: json.title || 'No title',\n      link: json.link || json.guid || json.id || '',\n      pubDate: pubDate,\n      source: source,\n      category: category,\n      content: json.contentSnippet || json.content || json.summary || json.description || ''\n    };\n  })\n  .filter(item => item.pubDate >= sevenDaysAgo)\n  .filter(item => {\n    if (!item.link || seen.has(item.link)) return false;\n    seen.add(item.link);\n    return true;\n  })\n  .sort((a, b) => b.pubDate - a.pubDate)\n  .slice(0, 30);\n\nif (filtered.length === 0) {\n  return [{\n    json: {\n      title: 'No posts found in last 7 days',\n      link: '',\n      pubDate: now.toISOString(),\n      source: 'System',\n      category: 'System',\n      content: 'No recent posts found. Check feed URLs or try again later.'\n    }\n  }];\n}\n\nreturn filtered.map(item => ({\n  json: {\n    title: item.title,\n    link: item.link,\n    pubDate: item.pubDate.toISOString(),\n    source: item.source,\n    category: item.category,\n    content: item.content.substring(0, 500)\n  }\n}));"
      },
      "id": "filter-sort",
      "name": "Filter & Sort",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [768, 464]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nconst byCategory = { Blog: [], Infrastructure: [], Community: [] };\nitems.forEach(item => {\n  const cat = item.json.category || 'Blog';\n  if (byCategory[cat]) byCategory[cat].push(item.json);\n});\n\nlet postsText = '';\n\nfor (const [category, posts] of Object.entries(byCategory)) {\n  if (posts.length === 0) continue;\n  postsText += `\\n## ${category} Sources\\n`;\n  posts.forEach((post) => {\n    postsText += `### ${post.title}\\n`;\n    postsText += `**Source:** ${post.source} | **Date:** ${post.pubDate}\\n`;\n    postsText += `**Link:** ${post.link}\\n`;\n    postsText += `**Preview:** ${post.content || 'No content'}\\n\\n`;\n  });\n}\n\nreturn [{\n  json: {\n    posts: postsText,\n    date: new Date().toISOString().split('T')[0],\n    itemCount: items.length\n  }\n}];"
      },
      "id": "prepare-for-llm",
      "name": "Prepare for LLM",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [960, 464]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-haiku-4-5-20251001",
          "mode": "list",
          "cachedResultName": "Claude Haiku 4.5"
        },
        "options": {
          "maxTokensToSample": 4096
        }
      },
      "id": "anthropic-model",
      "name": "Claude Haiku",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [1168, 640]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a DevOps and Infrastructure news analyst creating daily digests.\n\nYou have memory of your previous daily digest summaries. Use this memory to:\n- Focus on NEW content not covered in previous summaries\n- Avoid repeating information from previous digests\n- Reference trends or ongoing discussions if relevant\n\n## Today's Posts:\n{{ $json.posts }}\n\n## Instructions:\nCreate a markdown-formatted daily digest with these sections:\n\n1. **Key Releases & Announcements** - New tool versions, major updates, product launches\n2. **Infrastructure Trends** - GitOps, IaC, platform engineering, cloud native patterns\n3. **Community Highlights** - Hot discussions, popular tips, interesting debates\n4. **Tools & Tutorials** - New tools, how-to guides, best practices\n5. **Security Updates** - CVEs, security best practices, compliance news\n\nKeep summaries concise but informative. Focus on actionable insights.\nIf a section has no relevant NEW content, write \"No notable items today.\"\n\nFormat the output as clean markdown suitable for Notion.",
        "options": {}
      },
      "id": "ai-agent",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1168, 464]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "devops-daily-digest",
        "contextWindowLength": 10
      },
      "id": "simple-memory",
      "name": "Simple Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [1312, 656]
    },
    {
      "parameters": {
        "language": "javaScript",
        "mode": "runOnceForAllItems",
        "jsCode": "const item = $input.first();\n// AI Agent outputs to 'output' field, chainLlm outputs to 'text'\nconst text = item.json.output || item.json.text || '';\nconst maxLength = 1900;\nconst maxBlocks = 98;\n\nfunction parseRichText(text) {\n  const segments = [];\n  let remaining = text;\n  \n  while (remaining.length > 0) {\n    const boldMatch = remaining.match(/^\\*\\*(.+?)\\*\\*/);\n    const italicMatch = remaining.match(/^\\*(.+?)\\*/);\n    const codeMatch = remaining.match(/^`(.+?)`/);\n    const linkMatch = remaining.match(/^\\[(.+?)\\]\\((.+?)\\)/);\n    \n    if (boldMatch) {\n      segments.push({ type: 'text', text: { content: boldMatch[1] }, annotations: { bold: true } });\n      remaining = remaining.substring(boldMatch[0].length);\n    } else if (codeMatch) {\n      segments.push({ type: 'text', text: { content: codeMatch[1] }, annotations: { code: true } });\n      remaining = remaining.substring(codeMatch[0].length);\n    } else if (linkMatch) {\n      segments.push({ type: 'text', text: { content: linkMatch[1], link: { url: linkMatch[2] } } });\n      remaining = remaining.substring(linkMatch[0].length);\n    } else if (italicMatch && !remaining.startsWith('**')) {\n      segments.push({ type: 'text', text: { content: italicMatch[1] }, annotations: { italic: true } });\n      remaining = remaining.substring(italicMatch[0].length);\n    } else {\n      const nextSpecial = remaining.search(/\\*|`|\\[/);\n      const plainEnd = nextSpecial === -1 ? remaining.length : nextSpecial;\n      if (plainEnd > 0) {\n        segments.push({ type: 'text', text: { content: remaining.substring(0, plainEnd) } });\n        remaining = remaining.substring(plainEnd);\n      } else {\n        segments.push({ type: 'text', text: { content: remaining[0] } });\n        remaining = remaining.substring(1);\n      }\n    }\n  }\n  \n  return segments.length > 0 ? segments : [{ type: 'text', text: { content: text } }];\n}\n\nfunction splitRichText(segments) {\n  const result = [];\n  let current = [];\n  let currentLen = 0;\n  \n  for (const seg of segments) {\n    const content = seg.text.content;\n    if (currentLen + content.length <= maxLength) {\n      current.push(seg);\n      currentLen += content.length;\n    } else {\n      if (current.length > 0) result.push(current);\n      current = [seg];\n      currentLen = content.length;\n    }\n  }\n  if (current.length > 0) result.push(current);\n  return result;\n}\n\nconst lines = text.split('\\n');\nconst children = [];\n\nfor (const line of lines) {\n  if (children.length >= maxBlocks) break;\n  \n  const trimmed = line.trim();\n  if (!trimmed) continue;\n  \n  if (trimmed.startsWith('# ')) {\n    children.push({ object: 'block', type: 'heading_1', heading_1: { rich_text: parseRichText(trimmed.substring(2)) } });\n  } else if (trimmed.startsWith('## ')) {\n    children.push({ object: 'block', type: 'heading_2', heading_2: { rich_text: parseRichText(trimmed.substring(3)) } });\n  } else if (trimmed.startsWith('### ')) {\n    children.push({ object: 'block', type: 'heading_3', heading_3: { rich_text: parseRichText(trimmed.substring(4)) } });\n  } else if (trimmed === '---' || trimmed === '***' || trimmed === '___') {\n    children.push({ object: 'block', type: 'divider', divider: {} });\n  } else if (trimmed.startsWith('- ')) {\n    const richText = parseRichText(trimmed.substring(2));\n    const chunks = splitRichText(richText);\n    for (const chunk of chunks) {\n      if (children.length >= maxBlocks) break;\n      children.push({ object: 'block', type: 'bulleted_list_item', bulleted_list_item: { rich_text: chunk } });\n    }\n  } else if (/^\\d+\\.\\s/.test(trimmed)) {\n    const content = trimmed.replace(/^\\d+\\.\\s/, '');\n    children.push({ object: 'block', type: 'numbered_list_item', numbered_list_item: { rich_text: parseRichText(content) } });\n  } else {\n    const richText = parseRichText(trimmed);\n    const chunks = splitRichText(richText);\n    for (const chunk of chunks) {\n      if (children.length >= maxBlocks) break;\n      children.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: chunk } });\n    }\n  }\n}\n\nreturn [{ json: { notionChildren: children, date: new Date().toISOString().split('T')[0] } }];"
      },
      "id": "format-for-notion",
      "name": "Format for Notion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1520, 464]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/pages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Notion-Version", "value": "2022-06-28" },
            { "name": "Content-Type", "value": "application/json" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ parent: { page_id: '2d38e013c07f80c59d93c9aeb9e271b7' }, properties: { title: [{ text: { content: 'DevOps - ' + $json.date } }] }, children: $json.notionChildren }) }}",
        "options": {}
      },
      "id": "create-child-page",
      "name": "Create Notion Child Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1728, 464],
      "notesInFlow": true,
      "notes": "Requires 'Header Auth' credential with: Name=Authorization, Value=Bearer YOUR_NOTION_TOKEN"
    }
  ],
  "connections": {
    "Daily Trigger": {
      "main": [[
        { "node": "RSS DevOps.com", "type": "main", "index": 0 },
        { "node": "RSS Agile Admin", "type": "main", "index": 0 },
        { "node": "RSS InfoQ DevOps", "type": "main", "index": 0 },
        { "node": "RSS DevOps Daily", "type": "main", "index": 0 },
        { "node": "RSS HashiCorp", "type": "main", "index": 0 },
        { "node": "RSS CNCF", "type": "main", "index": 0 },
        { "node": "RSS Kubernetes", "type": "main", "index": 0 },
        { "node": "RSS HN DevOps", "type": "main", "index": 0 },
        { "node": "RSS r/devops", "type": "main", "index": 0 },
        { "node": "RSS r/kubernetes", "type": "main", "index": 0 }
      ]]
    },
    "RSS DevOps.com": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 0 }]] },
    "RSS Agile Admin": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 1 }]] },
    "RSS InfoQ DevOps": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 2 }]] },
    "RSS DevOps Daily": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 3 }]] },
    "RSS HashiCorp": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 4 }]] },
    "RSS CNCF": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 5 }]] },
    "RSS Kubernetes": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 6 }]] },
    "RSS HN DevOps": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 7 }]] },
    "RSS r/devops": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 8 }]] },
    "RSS r/kubernetes": { "main": [[{ "node": "Merge All Feeds", "type": "main", "index": 9 }]] },
    "Merge All Feeds": { "main": [[{ "node": "Filter & Sort", "type": "main", "index": 0 }]] },
    "Filter & Sort": { "main": [[{ "node": "Prepare for LLM", "type": "main", "index": 0 }]] },
    "Prepare for LLM": { "main": [[{ "node": "AI Agent", "type": "main", "index": 0 }]] },
    "Claude Haiku": { "ai_languageModel": [[{ "node": "AI Agent", "type": "ai_languageModel", "index": 0 }]] },
    "Simple Memory": { "ai_memory": [[{ "node": "AI Agent", "type": "ai_memory", "index": 0 }]] },
    "AI Agent": { "main": [[{ "node": "Format for Notion", "type": "main", "index": 0 }]] },
    "Format for Notion": { "main": [[{ "node": "Create Notion Child Page", "type": "main", "index": 0 }]] }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/New_York",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "meta": {
    "exportedAt": "2025-12-25T12:21:14.385Z",
    "n8nWorkflowId": "IfuKjEUqIOOXeWTM",
    "notes": "Uses AI Agent with Simple Memory for context across daily runs. Creates child pages under Daily News with 'DevOps - YYYY-MM-DD' title format."
  }
}
